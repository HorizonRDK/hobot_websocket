// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: x3.proto

#include "x3.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace x3 {
PROTOBUF_CONSTEXPR CharArray::CharArray(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , array__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct CharArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CharArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CharArrayDefaultTypeInternal() {}
  union {
    CharArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CharArrayDefaultTypeInternal _CharArray_default_instance_;
PROTOBUF_CONSTEXPR FloatArray::FloatArray(
    ::_pbi::ConstantInitialized)
  : value__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct FloatArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatArrayDefaultTypeInternal() {}
  union {
    FloatArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
PROTOBUF_CONSTEXPR FloatMatrix::FloatMatrix(
    ::_pbi::ConstantInitialized)
  : arrays__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct FloatMatrixDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatMatrixDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatMatrixDefaultTypeInternal() {}
  union {
    FloatMatrix _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatMatrixDefaultTypeInternal _FloatMatrix_default_instance_;
PROTOBUF_CONSTEXPR Point::Point(
    ::_pbi::ConstantInitialized)
  : x__(0)
  , y__(0)
  , score__(0){}
struct PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointDefaultTypeInternal() {}
  union {
    Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointDefaultTypeInternal _Point_default_instance_;
PROTOBUF_CONSTEXPR Points::Points(
    ::_pbi::ConstantInitialized)
  : points__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointsDefaultTypeInternal() {}
  union {
    Points _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointsDefaultTypeInternal _Points_default_instance_;
PROTOBUF_CONSTEXPR Box::Box(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , top_left__(nullptr)
  , bottom_right__(nullptr)
  , score_(0){}
struct BoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxDefaultTypeInternal() {}
  union {
    Box _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxDefaultTypeInternal _Box_default_instance_;
PROTOBUF_CONSTEXPR Attributes::Attributes(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_string__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value__(0)
  , score__(0){}
struct AttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttributesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttributesDefaultTypeInternal() {}
  union {
    Attributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttributesDefaultTypeInternal _Attributes_default_instance_;
PROTOBUF_CONSTEXPR DBResult::DBResult(
    ::_pbi::ConstantInitialized)
  : db_type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , match_id__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , distance__(0)
  , similarity__(0){}
struct DBResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DBResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DBResultDefaultTypeInternal() {}
  union {
    DBResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DBResultDefaultTypeInternal _DBResult_default_instance_;
PROTOBUF_CONSTEXPR Image::Image(
    ::_pbi::ConstantInitialized)
  : buf__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , width__(0u)
  , height__(0u){}
struct ImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageDefaultTypeInternal() {}
  union {
    Image _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageDefaultTypeInternal _Image_default_instance_;
PROTOBUF_CONSTEXPR Enable::Enable(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value__(false){}
struct EnableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnableDefaultTypeInternal() {}
  union {
    Enable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnableDefaultTypeInternal _Enable_default_instance_;
PROTOBUF_CONSTEXPR Threshold::Threshold(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value__(0){}
struct ThresholdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThresholdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThresholdDefaultTypeInternal() {}
  union {
    Threshold _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThresholdDefaultTypeInternal _Threshold_default_instance_;
PROTOBUF_CONSTEXPR Mode::Mode(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModeDefaultTypeInternal() {}
  union {
    Mode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModeDefaultTypeInternal _Mode_default_instance_;
PROTOBUF_CONSTEXPR Target::Target(
    ::_pbi::ConstantInitialized)
  : imgs__()
  , sub_targets__()
  , boxes__()
  , attributes__()
  , points__()
  , float_arrays__()
  , float_matrixs__()
  , char_arrays__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , track_id__(uint64_t{0u}){}
struct TargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TargetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TargetDefaultTypeInternal() {}
  union {
    Target _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TargetDefaultTypeInternal _Target_default_instance_;
PROTOBUF_CONSTEXPR SmartFrameMessage::SmartFrameMessage(
    ::_pbi::ConstantInitialized)
  : targets__()
  , timestamp__(uint64_t{0u})
  , error_code__(0u){}
struct SmartFrameMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartFrameMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartFrameMessageDefaultTypeInternal() {}
  union {
    SmartFrameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartFrameMessageDefaultTypeInternal _SmartFrameMessage_default_instance_;
PROTOBUF_CONSTEXPR Capture::Capture(
    ::_pbi::ConstantInitialized)
  : boxes__()
  , attributes__()
  , points__()
  , float_arrays__()
  , char_arrays__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , img__(nullptr)
  , timestamp__(uint64_t{0u}){}
struct CaptureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureDefaultTypeInternal() {}
  union {
    Capture _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureDefaultTypeInternal _Capture_default_instance_;
PROTOBUF_CONSTEXPR CaptureTarget::CaptureTarget(
    ::_pbi::ConstantInitialized)
  : captures__()
  , db_results__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , track_id__(uint64_t{0u}){}
struct CaptureTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureTargetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureTargetDefaultTypeInternal() {}
  union {
    CaptureTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureTargetDefaultTypeInternal _CaptureTarget_default_instance_;
PROTOBUF_CONSTEXPR CaptureFrameMessage::CaptureFrameMessage(
    ::_pbi::ConstantInitialized)
  : targets__(){}
struct CaptureFrameMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureFrameMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureFrameMessageDefaultTypeInternal() {}
  union {
    CaptureFrameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureFrameMessageDefaultTypeInternal _CaptureFrameMessage_default_instance_;
PROTOBUF_CONSTEXPR StatisticsMessage::StatisticsMessage(
    ::_pbi::ConstantInitialized)
  : attributes__(){}
struct StatisticsMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatisticsMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatisticsMessageDefaultTypeInternal() {}
  union {
    StatisticsMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatisticsMessageDefaultTypeInternal _StatisticsMessage_default_instance_;
PROTOBUF_CONSTEXPR FrameMessage::FrameMessage(
    ::_pbi::ConstantInitialized)
  : extimgs__()
  , smart_msg__(nullptr)
  , capture_msg__(nullptr)
  , statistics_msg__(nullptr)
  , img__(nullptr)
  , timestamp__(uint64_t{0u})
  , sequence_id__(uint64_t{0u}){}
struct FrameMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameMessageDefaultTypeInternal() {}
  union {
    FrameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameMessageDefaultTypeInternal _FrameMessage_default_instance_;
PROTOBUF_CONSTEXPR Capability::Capability(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cap_array__(nullptr){}
struct CapabilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CapabilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CapabilityDefaultTypeInternal() {}
  union {
    Capability _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CapabilityDefaultTypeInternal _Capability_default_instance_;
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
PROTOBUF_CONSTEXPR Config::Config(
    ::_pbi::ConstantInitialized)
  : threshold__()
  , mode__()
  , shield__()
  , type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigDefaultTypeInternal() {}
  union {
    Config _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigDefaultTypeInternal _Config_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp__(uint64_t{0u})
  , run_status__(0)
{}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
PROTOBUF_CONSTEXPR Command::Command(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp__(uint64_t{0u})
  , order__(0)
{}
struct CommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDefaultTypeInternal() {}
  union {
    Command _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDefaultTypeInternal _Command_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp__(uint64_t{0u})
  , ack__(0)
{}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
PROTOBUF_CONSTEXPR LogLevel::LogLevel(
    ::_pbi::ConstantInitialized)
  : type__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , level__(0)
{}
struct LogLevelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogLevelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogLevelDefaultTypeInternal() {}
  union {
    LogLevel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogLevelDefaultTypeInternal _LogLevel_default_instance_;
PROTOBUF_CONSTEXPR InfoMessage::InfoMessage(
    ::_pbi::ConstantInitialized)
  : config__()
  , version__()
  , capability__()
  , status__(nullptr)
  , command__(nullptr)
  , loglevel__(nullptr)
  , response__(nullptr){}
struct InfoMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoMessageDefaultTypeInternal() {}
  union {
    InfoMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoMessageDefaultTypeInternal _InfoMessage_default_instance_;
PROTOBUF_CONSTEXPR Frame::Frame(
    ::_pbi::ConstantInitialized)
  : sequence_id__(uint64_t{0u})
  , timestamp__(uint64_t{0u})
  , frame_type__(0)
{}
struct FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDefaultTypeInternal() {}
  union {
    Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDefaultTypeInternal _Frame_default_instance_;
PROTOBUF_CONSTEXPR Check::Check(
    ::_pbi::ConstantInitialized)
  : md5sum_(){}
struct CheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckDefaultTypeInternal() {}
  union {
    Check _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckDefaultTypeInternal _Check_default_instance_;
PROTOBUF_CONSTEXPR Addition::Addition(
    ::_pbi::ConstantInitialized)
  : check__(nullptr)
  , frame__(nullptr){}
struct AdditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdditionDefaultTypeInternal() {}
  union {
    Addition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdditionDefaultTypeInternal _Addition_default_instance_;
PROTOBUF_CONSTEXPR MessagePack::MessagePack(
    ::_pbi::ConstantInitialized)
  : content__(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , addition__(nullptr)
  , flow__(0)

  , type__(0)
{}
struct MessagePackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessagePackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessagePackDefaultTypeInternal() {}
  union {
    MessagePack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessagePackDefaultTypeInternal _MessagePack_default_instance_;
}  // namespace x3
namespace x3 {
bool Status_RunStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Status_RunStatus_strings[6] = {};

static const char Status_RunStatus_names[] =
  "Abnormal"
  "Init"
  "Normal"
  "Uknown"
  "Uninit"
  "Update";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Status_RunStatus_entries[] = {
  { {Status_RunStatus_names + 0, 8}, 4 },
  { {Status_RunStatus_names + 8, 4}, 2 },
  { {Status_RunStatus_names + 12, 6}, 3 },
  { {Status_RunStatus_names + 18, 6}, 0 },
  { {Status_RunStatus_names + 24, 6}, 1 },
  { {Status_RunStatus_names + 30, 6}, 5 },
};

static const int Status_RunStatus_entries_by_number[] = {
  3, // 0 -> Uknown
  4, // 1 -> Uninit
  1, // 2 -> Init
  2, // 3 -> Normal
  0, // 4 -> Abnormal
  5, // 5 -> Update
};

const std::string& Status_RunStatus_Name(
    Status_RunStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Status_RunStatus_entries,
          Status_RunStatus_entries_by_number,
          6, Status_RunStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Status_RunStatus_entries,
      Status_RunStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Status_RunStatus_strings[idx].get();
}
bool Status_RunStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_RunStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Status_RunStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Status_RunStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Status_RunStatus Status::Uknown;
constexpr Status_RunStatus Status::Uninit;
constexpr Status_RunStatus Status::Init;
constexpr Status_RunStatus Status::Normal;
constexpr Status_RunStatus Status::Abnormal;
constexpr Status_RunStatus Status::Update;
constexpr Status_RunStatus Status::RunStatus_MIN;
constexpr Status_RunStatus Status::RunStatus_MAX;
constexpr int Status::RunStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Command_Order_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Command_Order_strings[4] = {};

static const char Command_Order_names[] =
  "StartX2"
  "StopX2"
  "Unkown"
  "UpdateX2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Command_Order_entries[] = {
  { {Command_Order_names + 0, 7}, 1 },
  { {Command_Order_names + 7, 6}, 2 },
  { {Command_Order_names + 13, 6}, 0 },
  { {Command_Order_names + 19, 8}, 3 },
};

static const int Command_Order_entries_by_number[] = {
  2, // 0 -> Unkown
  0, // 1 -> StartX2
  1, // 2 -> StopX2
  3, // 3 -> UpdateX2
};

const std::string& Command_Order_Name(
    Command_Order value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Command_Order_entries,
          Command_Order_entries_by_number,
          4, Command_Order_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Command_Order_entries,
      Command_Order_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Command_Order_strings[idx].get();
}
bool Command_Order_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command_Order* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Command_Order_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Command_Order>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Command_Order Command::Unkown;
constexpr Command_Order Command::StartX2;
constexpr Command_Order Command::StopX2;
constexpr Command_Order Command::UpdateX2;
constexpr Command_Order Command::Order_MIN;
constexpr Command_Order Command::Order_MAX;
constexpr int Command::Order_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Response_Ack_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Response_Ack_strings[3] = {};

static const char Response_Ack_names[] =
  "Fail"
  "Success"
  "Uknown";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Response_Ack_entries[] = {
  { {Response_Ack_names + 0, 4}, 2 },
  { {Response_Ack_names + 4, 7}, 1 },
  { {Response_Ack_names + 11, 6}, 0 },
};

static const int Response_Ack_entries_by_number[] = {
  2, // 0 -> Uknown
  1, // 1 -> Success
  0, // 2 -> Fail
};

const std::string& Response_Ack_Name(
    Response_Ack value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Response_Ack_entries,
          Response_Ack_entries_by_number,
          3, Response_Ack_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Response_Ack_entries,
      Response_Ack_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Response_Ack_strings[idx].get();
}
bool Response_Ack_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Response_Ack* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Response_Ack_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Response_Ack>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Response_Ack Response::Uknown;
constexpr Response_Ack Response::Success;
constexpr Response_Ack Response::Fail;
constexpr Response_Ack Response::Ack_MIN;
constexpr Response_Ack Response::Ack_MAX;
constexpr int Response::Ack_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LogLevel_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogLevel_Level_strings[7] = {};

static const char LogLevel_Level_names[] =
  "X2_DEBUG"
  "X2_ERROR"
  "X2_FATAL"
  "X2_INFO"
  "X2_NONE"
  "X2_NOTICE"
  "X2_WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogLevel_Level_entries[] = {
  { {LogLevel_Level_names + 0, 8}, 0 },
  { {LogLevel_Level_names + 8, 8}, 4 },
  { {LogLevel_Level_names + 16, 8}, 5 },
  { {LogLevel_Level_names + 24, 7}, 1 },
  { {LogLevel_Level_names + 31, 7}, 6 },
  { {LogLevel_Level_names + 38, 9}, 2 },
  { {LogLevel_Level_names + 47, 7}, 3 },
};

static const int LogLevel_Level_entries_by_number[] = {
  0, // 0 -> X2_DEBUG
  3, // 1 -> X2_INFO
  5, // 2 -> X2_NOTICE
  6, // 3 -> X2_WARN
  1, // 4 -> X2_ERROR
  2, // 5 -> X2_FATAL
  4, // 6 -> X2_NONE
};

const std::string& LogLevel_Level_Name(
    LogLevel_Level value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogLevel_Level_entries,
          LogLevel_Level_entries_by_number,
          7, LogLevel_Level_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogLevel_Level_entries,
      LogLevel_Level_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogLevel_Level_strings[idx].get();
}
bool LogLevel_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel_Level* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogLevel_Level_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<LogLevel_Level>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LogLevel_Level LogLevel::X2_DEBUG;
constexpr LogLevel_Level LogLevel::X2_INFO;
constexpr LogLevel_Level LogLevel::X2_NOTICE;
constexpr LogLevel_Level LogLevel::X2_WARN;
constexpr LogLevel_Level LogLevel::X2_ERROR;
constexpr LogLevel_Level LogLevel::X2_FATAL;
constexpr LogLevel_Level LogLevel::X2_NONE;
constexpr LogLevel_Level LogLevel::Level_MIN;
constexpr LogLevel_Level LogLevel::Level_MAX;
constexpr int LogLevel::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Frame_FrameType_strings[4] = {};

static const char Frame_FrameType_names[] =
  "DropFrame"
  "ErrorFrame"
  "SmartFrame"
  "Unkown";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Frame_FrameType_entries[] = {
  { {Frame_FrameType_names + 0, 9}, 2 },
  { {Frame_FrameType_names + 9, 10}, 3 },
  { {Frame_FrameType_names + 19, 10}, 1 },
  { {Frame_FrameType_names + 29, 6}, 0 },
};

static const int Frame_FrameType_entries_by_number[] = {
  3, // 0 -> Unkown
  2, // 1 -> SmartFrame
  0, // 2 -> DropFrame
  1, // 3 -> ErrorFrame
};

const std::string& Frame_FrameType_Name(
    Frame_FrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Frame_FrameType_entries,
          Frame_FrameType_entries_by_number,
          4, Frame_FrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Frame_FrameType_entries,
      Frame_FrameType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Frame_FrameType_strings[idx].get();
}
bool Frame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Frame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Frame_FrameType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Frame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Frame_FrameType Frame::Unkown;
constexpr Frame_FrameType Frame::SmartFrame;
constexpr Frame_FrameType Frame::DropFrame;
constexpr Frame_FrameType Frame::ErrorFrame;
constexpr Frame_FrameType Frame::FrameType_MIN;
constexpr Frame_FrameType Frame::FrameType_MAX;
constexpr int Frame::FrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool MessagePack_Flow_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessagePack_Flow_strings[3] = {};

static const char MessagePack_Flow_names[] =
  "AP2CP"
  "CP2AP"
  "Unknown";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessagePack_Flow_entries[] = {
  { {MessagePack_Flow_names + 0, 5}, 1 },
  { {MessagePack_Flow_names + 5, 5}, 2 },
  { {MessagePack_Flow_names + 10, 7}, 0 },
};

static const int MessagePack_Flow_entries_by_number[] = {
  2, // 0 -> Unknown
  0, // 1 -> AP2CP
  1, // 2 -> CP2AP
};

const std::string& MessagePack_Flow_Name(
    MessagePack_Flow value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessagePack_Flow_entries,
          MessagePack_Flow_entries_by_number,
          3, MessagePack_Flow_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessagePack_Flow_entries,
      MessagePack_Flow_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessagePack_Flow_strings[idx].get();
}
bool MessagePack_Flow_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessagePack_Flow* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessagePack_Flow_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MessagePack_Flow>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MessagePack_Flow MessagePack::Unknown;
constexpr MessagePack_Flow MessagePack::AP2CP;
constexpr MessagePack_Flow MessagePack::CP2AP;
constexpr MessagePack_Flow MessagePack::Flow_MIN;
constexpr MessagePack_Flow MessagePack::Flow_MAX;
constexpr int MessagePack::Flow_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool MessagePack_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessagePack_Type_strings[3] = {};

static const char MessagePack_Type_names[] =
  "kUnknown"
  "kXConfig"
  "kXPlugin";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessagePack_Type_entries[] = {
  { {MessagePack_Type_names + 0, 8}, 0 },
  { {MessagePack_Type_names + 8, 8}, 2 },
  { {MessagePack_Type_names + 16, 8}, 1 },
};

static const int MessagePack_Type_entries_by_number[] = {
  0, // 0 -> kUnknown
  2, // 1 -> kXPlugin
  1, // 2 -> kXConfig
};

const std::string& MessagePack_Type_Name(
    MessagePack_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessagePack_Type_entries,
          MessagePack_Type_entries_by_number,
          3, MessagePack_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessagePack_Type_entries,
      MessagePack_Type_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessagePack_Type_strings[idx].get();
}
bool MessagePack_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessagePack_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessagePack_Type_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MessagePack_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MessagePack_Type MessagePack::kUnknown;
constexpr MessagePack_Type MessagePack::kXPlugin;
constexpr MessagePack_Type MessagePack::kXConfig;
constexpr MessagePack_Type MessagePack::Type_MIN;
constexpr MessagePack_Type MessagePack::Type_MAX;
constexpr int MessagePack::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class CharArray::_Internal {
 public:
};

CharArray::CharArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.CharArray)
}
CharArray::CharArray(const CharArray& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  array__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    array__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_array_().empty()) {
    array__.Set(from._internal_array_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.CharArray)
}

inline void CharArray::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
array__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  array__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CharArray::~CharArray() {
  // @@protoc_insertion_point(destructor:x3.CharArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CharArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  array__.Destroy();
}

void CharArray::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CharArray::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.CharArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  array__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* CharArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes array_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_array_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CharArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.CharArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.CharArray.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // bytes array_ = 2;
  if (!this->_internal_array_().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_array_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.CharArray)
  return target;
}

size_t CharArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.CharArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // bytes array_ = 2;
  if (!this->_internal_array_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_array_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CharArray::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CharArray*>(
      &from));
}

void CharArray::MergeFrom(const CharArray& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.CharArray)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (!from._internal_array_().empty()) {
    _internal_set_array_(from._internal_array_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CharArray::CopyFrom(const CharArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.CharArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CharArray::IsInitialized() const {
  return true;
}

void CharArray::InternalSwap(CharArray* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &array__, lhs_arena,
      &other->array__, rhs_arena
  );
}

std::string CharArray::GetTypeName() const {
  return "x3.CharArray";
}


// ===================================================================

class FloatArray::_Internal {
 public:
};

FloatArray::FloatArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  value__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.FloatArray)
}
FloatArray::FloatArray(const FloatArray& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      value__(from.value__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.FloatArray)
}

inline void FloatArray::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FloatArray::~FloatArray() {
  // @@protoc_insertion_point(destructor:x3.FloatArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FloatArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void FloatArray::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloatArray::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.FloatArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value__.Clear();
  type__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* FloatArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated float value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_value_(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_value_(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloatArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.FloatArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.FloatArray.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // repeated float value_ = 2;
  if (this->_internal_value__size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_value_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.FloatArray)
  return target;
}

size_t FloatArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.FloatArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float value_ = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_value__size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloatArray::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FloatArray*>(
      &from));
}

void FloatArray::MergeFrom(const FloatArray& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.FloatArray)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  value__.MergeFrom(from.value__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloatArray::CopyFrom(const FloatArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.FloatArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatArray::IsInitialized() const {
  return true;
}

void FloatArray::InternalSwap(FloatArray* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  value__.InternalSwap(&other->value__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
}

std::string FloatArray::GetTypeName() const {
  return "x3.FloatArray";
}


// ===================================================================

class FloatMatrix::_Internal {
 public:
};

FloatMatrix::FloatMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  arrays__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.FloatMatrix)
}
FloatMatrix::FloatMatrix(const FloatMatrix& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      arrays__(from.arrays__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.FloatMatrix)
}

inline void FloatMatrix::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FloatMatrix::~FloatMatrix() {
  // @@protoc_insertion_point(destructor:x3.FloatMatrix)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FloatMatrix::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void FloatMatrix::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloatMatrix::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.FloatMatrix)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arrays__.Clear();
  type__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* FloatMatrix::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.FloatArray arrays_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arrays_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloatMatrix::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.FloatMatrix)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.FloatMatrix.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // repeated .x3.FloatArray arrays_ = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_arrays__size()); i < n; i++) {
    const auto& repfield = this->_internal_arrays_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.FloatMatrix)
  return target;
}

size_t FloatMatrix::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.FloatMatrix)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.FloatArray arrays_ = 2;
  total_size += 1UL * this->_internal_arrays__size();
  for (const auto& msg : this->arrays__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloatMatrix::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FloatMatrix*>(
      &from));
}

void FloatMatrix::MergeFrom(const FloatMatrix& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.FloatMatrix)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  arrays__.MergeFrom(from.arrays__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloatMatrix::CopyFrom(const FloatMatrix& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.FloatMatrix)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatMatrix::IsInitialized() const {
  return true;
}

void FloatMatrix::InternalSwap(FloatMatrix* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  arrays__.InternalSwap(&other->arrays__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
}

std::string FloatMatrix::GetTypeName() const {
  return "x3.FloatMatrix";
}


// ===================================================================

class Point::_Internal {
 public:
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&x__, &from.x__,
    static_cast<size_t>(reinterpret_cast<char*>(&score__) -
    reinterpret_cast<char*>(&x__)) + sizeof(score__));
  // @@protoc_insertion_point(copy_constructor:x3.Point)
}

inline void Point::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&score__) -
    reinterpret_cast<char*>(&x__)) + sizeof(score__));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:x3.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&score__) -
      reinterpret_cast<char*>(&x__)) + sizeof(score__));
  _internal_metadata_.Clear<std::string>();
}

const char* Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          x__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          y__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float score_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          score__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x_ = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x_ = this->_internal_x_();
  uint32_t raw_x_;
  memcpy(&raw_x_, &tmp_x_, sizeof(tmp_x_));
  if (raw_x_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x_(), target);
  }

  // float y_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y_ = this->_internal_y_();
  uint32_t raw_y_;
  memcpy(&raw_y_, &tmp_y_, sizeof(tmp_y_));
  if (raw_y_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y_(), target);
  }

  // float score_ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = this->_internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_score_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Point)
  return target;
}

size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x_ = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x_ = this->_internal_x_();
  uint32_t raw_x_;
  memcpy(&raw_x_, &tmp_x_, sizeof(tmp_x_));
  if (raw_x_ != 0) {
    total_size += 1 + 4;
  }

  // float y_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y_ = this->_internal_y_();
  uint32_t raw_y_;
  memcpy(&raw_y_, &tmp_y_, sizeof(tmp_y_));
  if (raw_y_ != 0) {
    total_size += 1 + 4;
  }

  // float score_ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = this->_internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Point::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Point*>(
      &from));
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Point)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x_ = from._internal_x_();
  uint32_t raw_x_;
  memcpy(&raw_x_, &tmp_x_, sizeof(tmp_x_));
  if (raw_x_ != 0) {
    _internal_set_x_(from._internal_x_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y_ = from._internal_y_();
  uint32_t raw_y_;
  memcpy(&raw_y_, &tmp_y_, sizeof(tmp_y_));
  if (raw_y_ != 0) {
    _internal_set_y_(from._internal_y_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = from._internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    _internal_set_score_(from._internal_score_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, score__)
      + sizeof(Point::score__)
      - PROTOBUF_FIELD_OFFSET(Point, x__)>(
          reinterpret_cast<char*>(&x__),
          reinterpret_cast<char*>(&other->x__));
}

std::string Point::GetTypeName() const {
  return "x3.Point";
}


// ===================================================================

class Points::_Internal {
 public:
};

Points::Points(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  points__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Points)
}
Points::Points(const Points& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      points__(from.points__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.Points)
}

inline void Points::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Points::~Points() {
  // @@protoc_insertion_point(destructor:x3.Points)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Points::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Points::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Points::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Points)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points__.Clear();
  type__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Points::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Point points_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Points::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Points)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Points.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // repeated .x3.Point points_ = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points__size()); i < n; i++) {
    const auto& repfield = this->_internal_points_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Points)
  return target;
}

size_t Points::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Points)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Point points_ = 2;
  total_size += 1UL * this->_internal_points__size();
  for (const auto& msg : this->points__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Points::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Points*>(
      &from));
}

void Points::MergeFrom(const Points& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Points)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  points__.MergeFrom(from.points__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Points::CopyFrom(const Points& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Points)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Points::IsInitialized() const {
  return true;
}

void Points::InternalSwap(Points* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  points__.InternalSwap(&other->points__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
}

std::string Points::GetTypeName() const {
  return "x3.Points";
}


// ===================================================================

class Box::_Internal {
 public:
  static const ::x3::Point& top_left_(const Box* msg);
  static const ::x3::Point& bottom_right_(const Box* msg);
};

const ::x3::Point&
Box::_Internal::top_left_(const Box* msg) {
  return *msg->top_left__;
}
const ::x3::Point&
Box::_Internal::bottom_right_(const Box* msg) {
  return *msg->bottom_right__;
}
Box::Box(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Box)
}
Box::Box(const Box& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_top_left_()) {
    top_left__ = new ::x3::Point(*from.top_left__);
  } else {
    top_left__ = nullptr;
  }
  if (from._internal_has_bottom_right_()) {
    bottom_right__ = new ::x3::Point(*from.bottom_right__);
  } else {
    bottom_right__ = nullptr;
  }
  score_ = from.score_;
  // @@protoc_insertion_point(copy_constructor:x3.Box)
}

inline void Box::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&top_left__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&score_) -
    reinterpret_cast<char*>(&top_left__)) + sizeof(score_));
}

Box::~Box() {
  // @@protoc_insertion_point(destructor:x3.Box)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Box::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  if (this != internal_default_instance()) delete top_left__;
  if (this != internal_default_instance()) delete bottom_right__;
}

void Box::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Box::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Box)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && top_left__ != nullptr) {
    delete top_left__;
  }
  top_left__ = nullptr;
  if (GetArenaForAllocation() == nullptr && bottom_right__ != nullptr) {
    delete bottom_right__;
  }
  bottom_right__ = nullptr;
  score_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Box::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .x3.Point top_left_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_top_left_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Point bottom_right_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bottom_right_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Box::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Box)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Box.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // .x3.Point top_left_ = 2;
  if (this->_internal_has_top_left_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::top_left_(this),
        _Internal::top_left_(this).GetCachedSize(), target, stream);
  }

  // .x3.Point bottom_right_ = 3;
  if (this->_internal_has_bottom_right_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bottom_right_(this),
        _Internal::bottom_right_(this).GetCachedSize(), target, stream);
  }

  // float score = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score = this->_internal_score();
  uint32_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Box)
  return target;
}

size_t Box::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Box)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // .x3.Point top_left_ = 2;
  if (this->_internal_has_top_left_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *top_left__);
  }

  // .x3.Point bottom_right_ = 3;
  if (this->_internal_has_bottom_right_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bottom_right__);
  }

  // float score = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score = this->_internal_score();
  uint32_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Box::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Box*>(
      &from));
}

void Box::MergeFrom(const Box& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Box)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_has_top_left_()) {
    _internal_mutable_top_left_()->::x3::Point::MergeFrom(from._internal_top_left_());
  }
  if (from._internal_has_bottom_right_()) {
    _internal_mutable_bottom_right_()->::x3::Point::MergeFrom(from._internal_bottom_right_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score = from._internal_score();
  uint32_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    _internal_set_score(from._internal_score());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Box::CopyFrom(const Box& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Box)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box::IsInitialized() const {
  return true;
}

void Box::InternalSwap(Box* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Box, score_)
      + sizeof(Box::score_)
      - PROTOBUF_FIELD_OFFSET(Box, top_left__)>(
          reinterpret_cast<char*>(&top_left__),
          reinterpret_cast<char*>(&other->top_left__));
}

std::string Box::GetTypeName() const {
  return "x3.Box";
}


// ===================================================================

class Attributes::_Internal {
 public:
};

Attributes::Attributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Attributes)
}
Attributes::Attributes(const Attributes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  value_string__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_string__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value_string_().empty()) {
    value_string__.Set(from._internal_value_string_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&value__, &from.value__,
    static_cast<size_t>(reinterpret_cast<char*>(&score__) -
    reinterpret_cast<char*>(&value__)) + sizeof(score__));
  // @@protoc_insertion_point(copy_constructor:x3.Attributes)
}

inline void Attributes::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_string__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_string__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&score__) -
    reinterpret_cast<char*>(&value__)) + sizeof(score__));
}

Attributes::~Attributes() {
  // @@protoc_insertion_point(destructor:x3.Attributes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Attributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  value_string__.Destroy();
}

void Attributes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Attributes::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Attributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  value_string__.ClearToEmpty();
  ::memset(&value__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&score__) -
      reinterpret_cast<char*>(&value__)) + sizeof(score__));
  _internal_metadata_.Clear<std::string>();
}

const char* Attributes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          value__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string value_string_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value_string_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float score_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          score__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Attributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Attributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Attributes.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // float value_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = this->_internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value_(), target);
  }

  // string value_string_ = 3;
  if (!this->_internal_value_string_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value_string_().data(), static_cast<int>(this->_internal_value_string_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Attributes.value_string_");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value_string_(), target);
  }

  // float score_ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = this->_internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_score_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Attributes)
  return target;
}

size_t Attributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Attributes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // string value_string_ = 3;
  if (!this->_internal_value_string_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value_string_());
  }

  // float value_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = this->_internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    total_size += 1 + 4;
  }

  // float score_ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = this->_internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Attributes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Attributes*>(
      &from));
}

void Attributes::MergeFrom(const Attributes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Attributes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (!from._internal_value_string_().empty()) {
    _internal_set_value_string_(from._internal_value_string_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = from._internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    _internal_set_value_(from._internal_value_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_score_ = from._internal_score_();
  uint32_t raw_score_;
  memcpy(&raw_score_, &tmp_score_, sizeof(tmp_score_));
  if (raw_score_ != 0) {
    _internal_set_score_(from._internal_score_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Attributes::CopyFrom(const Attributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Attributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attributes::IsInitialized() const {
  return true;
}

void Attributes::InternalSwap(Attributes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_string__, lhs_arena,
      &other->value_string__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Attributes, score__)
      + sizeof(Attributes::score__)
      - PROTOBUF_FIELD_OFFSET(Attributes, value__)>(
          reinterpret_cast<char*>(&value__),
          reinterpret_cast<char*>(&other->value__));
}

std::string Attributes::GetTypeName() const {
  return "x3.Attributes";
}


// ===================================================================

class DBResult::_Internal {
 public:
};

DBResult::DBResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.DBResult)
}
DBResult::DBResult(const DBResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  db_type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    db_type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_db_type_().empty()) {
    db_type__.Set(from._internal_db_type_(), 
      GetArenaForAllocation());
  }
  match_id__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    match_id__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_match_id_().empty()) {
    match_id__.Set(from._internal_match_id_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&distance__, &from.distance__,
    static_cast<size_t>(reinterpret_cast<char*>(&similarity__) -
    reinterpret_cast<char*>(&distance__)) + sizeof(similarity__));
  // @@protoc_insertion_point(copy_constructor:x3.DBResult)
}

inline void DBResult::SharedCtor() {
db_type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  db_type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
match_id__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  match_id__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&distance__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&similarity__) -
    reinterpret_cast<char*>(&distance__)) + sizeof(similarity__));
}

DBResult::~DBResult() {
  // @@protoc_insertion_point(destructor:x3.DBResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DBResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  db_type__.Destroy();
  match_id__.Destroy();
}

void DBResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DBResult::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.DBResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  db_type__.ClearToEmpty();
  match_id__.ClearToEmpty();
  ::memset(&distance__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&similarity__) -
      reinterpret_cast<char*>(&distance__)) + sizeof(similarity__));
  _internal_metadata_.Clear<std::string>();
}

const char* DBResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string db_type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_db_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string match_id_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_match_id_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float distance_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          distance__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float similarity_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          similarity__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DBResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.DBResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string db_type_ = 1;
  if (!this->_internal_db_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_db_type_().data(), static_cast<int>(this->_internal_db_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.DBResult.db_type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_db_type_(), target);
  }

  // string match_id_ = 2;
  if (!this->_internal_match_id_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_match_id_().data(), static_cast<int>(this->_internal_match_id_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.DBResult.match_id_");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_match_id_(), target);
  }

  // float distance_ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_ = this->_internal_distance_();
  uint32_t raw_distance_;
  memcpy(&raw_distance_, &tmp_distance_, sizeof(tmp_distance_));
  if (raw_distance_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_distance_(), target);
  }

  // float similarity_ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_similarity_ = this->_internal_similarity_();
  uint32_t raw_similarity_;
  memcpy(&raw_similarity_, &tmp_similarity_, sizeof(tmp_similarity_));
  if (raw_similarity_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_similarity_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.DBResult)
  return target;
}

size_t DBResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.DBResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string db_type_ = 1;
  if (!this->_internal_db_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_db_type_());
  }

  // string match_id_ = 2;
  if (!this->_internal_match_id_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_match_id_());
  }

  // float distance_ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_ = this->_internal_distance_();
  uint32_t raw_distance_;
  memcpy(&raw_distance_, &tmp_distance_, sizeof(tmp_distance_));
  if (raw_distance_ != 0) {
    total_size += 1 + 4;
  }

  // float similarity_ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_similarity_ = this->_internal_similarity_();
  uint32_t raw_similarity_;
  memcpy(&raw_similarity_, &tmp_similarity_, sizeof(tmp_similarity_));
  if (raw_similarity_ != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DBResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DBResult*>(
      &from));
}

void DBResult::MergeFrom(const DBResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.DBResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_db_type_().empty()) {
    _internal_set_db_type_(from._internal_db_type_());
  }
  if (!from._internal_match_id_().empty()) {
    _internal_set_match_id_(from._internal_match_id_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance_ = from._internal_distance_();
  uint32_t raw_distance_;
  memcpy(&raw_distance_, &tmp_distance_, sizeof(tmp_distance_));
  if (raw_distance_ != 0) {
    _internal_set_distance_(from._internal_distance_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_similarity_ = from._internal_similarity_();
  uint32_t raw_similarity_;
  memcpy(&raw_similarity_, &tmp_similarity_, sizeof(tmp_similarity_));
  if (raw_similarity_ != 0) {
    _internal_set_similarity_(from._internal_similarity_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DBResult::CopyFrom(const DBResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.DBResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DBResult::IsInitialized() const {
  return true;
}

void DBResult::InternalSwap(DBResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &db_type__, lhs_arena,
      &other->db_type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &match_id__, lhs_arena,
      &other->match_id__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DBResult, similarity__)
      + sizeof(DBResult::similarity__)
      - PROTOBUF_FIELD_OFFSET(DBResult, distance__)>(
          reinterpret_cast<char*>(&distance__),
          reinterpret_cast<char*>(&other->distance__));
}

std::string DBResult::GetTypeName() const {
  return "x3.DBResult";
}


// ===================================================================

class Image::_Internal {
 public:
};

Image::Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Image)
}
Image::Image(const Image& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  buf__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    buf__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_buf_().empty()) {
    buf__.Set(from._internal_buf_(), 
      GetArenaForAllocation());
  }
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&width__, &from.width__,
    static_cast<size_t>(reinterpret_cast<char*>(&height__) -
    reinterpret_cast<char*>(&width__)) + sizeof(height__));
  // @@protoc_insertion_point(copy_constructor:x3.Image)
}

inline void Image::SharedCtor() {
buf__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  buf__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height__) -
    reinterpret_cast<char*>(&width__)) + sizeof(height__));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:x3.Image)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Image::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  buf__.Destroy();
  type__.Destroy();
}

void Image::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Image)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  buf__.ClearToEmpty();
  type__.ClearToEmpty();
  ::memset(&width__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height__) -
      reinterpret_cast<char*>(&width__)) + sizeof(height__));
  _internal_metadata_.Clear<std::string>();
}

const char* Image::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes buf_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_buf_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string type_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 width_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          width__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          height__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Image::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Image)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes buf_ = 1;
  if (!this->_internal_buf_().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_buf_(), target);
  }

  // string type_ = 2;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Image.type_");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type_(), target);
  }

  // uint32 width_ = 3;
  if (this->_internal_width_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_width_(), target);
  }

  // uint32 height_ = 4;
  if (this->_internal_height_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_height_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Image)
  return target;
}

size_t Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Image)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes buf_ = 1;
  if (!this->_internal_buf_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_buf_());
  }

  // string type_ = 2;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint32 width_ = 3;
  if (this->_internal_width_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width_());
  }

  // uint32 height_ = 4;
  if (this->_internal_height_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Image::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Image*>(
      &from));
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Image)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_buf_().empty()) {
    _internal_set_buf_(from._internal_buf_());
  }
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_width_() != 0) {
    _internal_set_width_(from._internal_width_());
  }
  if (from._internal_height_() != 0) {
    _internal_set_height_(from._internal_height_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  return true;
}

void Image::InternalSwap(Image* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &buf__, lhs_arena,
      &other->buf__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Image, height__)
      + sizeof(Image::height__)
      - PROTOBUF_FIELD_OFFSET(Image, width__)>(
          reinterpret_cast<char*>(&width__),
          reinterpret_cast<char*>(&other->width__));
}

std::string Image::GetTypeName() const {
  return "x3.Image";
}


// ===================================================================

class Enable::_Internal {
 public:
};

Enable::Enable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Enable)
}
Enable::Enable(const Enable& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  value__ = from.value__;
  // @@protoc_insertion_point(copy_constructor:x3.Enable)
}

inline void Enable::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value__ = false;
}

Enable::~Enable() {
  // @@protoc_insertion_point(destructor:x3.Enable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Enable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Enable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Enable::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Enable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  value__ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* Enable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          value__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Enable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Enable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Enable.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // bool value_ = 2;
  if (this->_internal_value_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_value_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Enable)
  return target;
}

size_t Enable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Enable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // bool value_ = 2;
  if (this->_internal_value_() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Enable::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Enable*>(
      &from));
}

void Enable::MergeFrom(const Enable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Enable)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_value_() != 0) {
    _internal_set_value_(from._internal_value_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Enable::CopyFrom(const Enable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Enable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Enable::IsInitialized() const {
  return true;
}

void Enable::InternalSwap(Enable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(value__, other->value__);
}

std::string Enable::GetTypeName() const {
  return "x3.Enable";
}


// ===================================================================

class Threshold::_Internal {
 public:
};

Threshold::Threshold(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Threshold)
}
Threshold::Threshold(const Threshold& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  value__ = from.value__;
  // @@protoc_insertion_point(copy_constructor:x3.Threshold)
}

inline void Threshold::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value__ = 0;
}

Threshold::~Threshold() {
  // @@protoc_insertion_point(destructor:x3.Threshold)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Threshold::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Threshold::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Threshold::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Threshold)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  value__ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Threshold::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          value__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Threshold::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Threshold)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Threshold.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // float value_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = this->_internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Threshold)
  return target;
}

size_t Threshold::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Threshold)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // float value_ = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = this->_internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Threshold::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Threshold*>(
      &from));
}

void Threshold::MergeFrom(const Threshold& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Threshold)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value_ = from._internal_value_();
  uint32_t raw_value_;
  memcpy(&raw_value_, &tmp_value_, sizeof(tmp_value_));
  if (raw_value_ != 0) {
    _internal_set_value_(from._internal_value_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Threshold::CopyFrom(const Threshold& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Threshold)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Threshold::IsInitialized() const {
  return true;
}

void Threshold::InternalSwap(Threshold* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(value__, other->value__);
}

std::string Threshold::GetTypeName() const {
  return "x3.Threshold";
}


// ===================================================================

class Mode::_Internal {
 public:
};

Mode::Mode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Mode)
}
Mode::Mode(const Mode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  value__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value_().empty()) {
    value__.Set(from._internal_value_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.Mode)
}

inline void Mode::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Mode::~Mode() {
  // @@protoc_insertion_point(destructor:x3.Mode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Mode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  value__.Destroy();
}

void Mode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Mode::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Mode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  value__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Mode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Mode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Mode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Mode.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // string value_ = 2;
  if (!this->_internal_value_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value_().data(), static_cast<int>(this->_internal_value_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Mode.value_");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Mode)
  return target;
}

size_t Mode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Mode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // string value_ = 2;
  if (!this->_internal_value_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Mode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Mode*>(
      &from));
}

void Mode::MergeFrom(const Mode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Mode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (!from._internal_value_().empty()) {
    _internal_set_value_(from._internal_value_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Mode::CopyFrom(const Mode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Mode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mode::IsInitialized() const {
  return true;
}

void Mode::InternalSwap(Mode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value__, lhs_arena,
      &other->value__, rhs_arena
  );
}

std::string Mode::GetTypeName() const {
  return "x3.Mode";
}


// ===================================================================

class Target::_Internal {
 public:
};

Target::Target(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  imgs__(arena),
  sub_targets__(arena),
  boxes__(arena),
  attributes__(arena),
  points__(arena),
  float_arrays__(arena),
  float_matrixs__(arena),
  char_arrays__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Target)
}
Target::Target(const Target& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      imgs__(from.imgs__),
      sub_targets__(from.sub_targets__),
      boxes__(from.boxes__),
      attributes__(from.attributes__),
      points__(from.points__),
      float_arrays__(from.float_arrays__),
      float_matrixs__(from.float_matrixs__),
      char_arrays__(from.char_arrays__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  track_id__ = from.track_id__;
  // @@protoc_insertion_point(copy_constructor:x3.Target)
}

inline void Target::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
track_id__ = uint64_t{0u};
}

Target::~Target() {
  // @@protoc_insertion_point(destructor:x3.Target)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Target::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Target::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Target::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Target)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  imgs__.Clear();
  sub_targets__.Clear();
  boxes__.Clear();
  attributes__.Clear();
  points__.Clear();
  float_arrays__.Clear();
  float_matrixs__.Clear();
  char_arrays__.Clear();
  type__.ClearToEmpty();
  track_id__ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Target::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 track_id_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          track_id__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Image imgs_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_imgs_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Target sub_targets_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sub_targets_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Box boxes_ = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_boxes_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Attributes attributes_ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attributes_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Points points_ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.FloatArray float_arrays_ = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_float_arrays_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.FloatMatrix float_matrixs_ = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_float_matrixs_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.CharArray char_arrays_ = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_char_arrays_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Target::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Target)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Target.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // uint64 track_id_ = 2;
  if (this->_internal_track_id_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_track_id_(), target);
  }

  // repeated .x3.Image imgs_ = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_imgs__size()); i < n; i++) {
    const auto& repfield = this->_internal_imgs_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Target sub_targets_ = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sub_targets__size()); i < n; i++) {
    const auto& repfield = this->_internal_sub_targets_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Box boxes_ = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_boxes__size()); i < n; i++) {
    const auto& repfield = this->_internal_boxes_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Attributes attributes_ = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributes__size()); i < n; i++) {
    const auto& repfield = this->_internal_attributes_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Points points_ = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points__size()); i < n; i++) {
    const auto& repfield = this->_internal_points_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.FloatArray float_arrays_ = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_float_arrays__size()); i < n; i++) {
    const auto& repfield = this->_internal_float_arrays_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.FloatMatrix float_matrixs_ = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_float_matrixs__size()); i < n; i++) {
    const auto& repfield = this->_internal_float_matrixs_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.CharArray char_arrays_ = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_char_arrays__size()); i < n; i++) {
    const auto& repfield = this->_internal_char_arrays_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Target)
  return target;
}

size_t Target::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Target)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Image imgs_ = 3;
  total_size += 1UL * this->_internal_imgs__size();
  for (const auto& msg : this->imgs__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Target sub_targets_ = 4;
  total_size += 1UL * this->_internal_sub_targets__size();
  for (const auto& msg : this->sub_targets__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Box boxes_ = 5;
  total_size += 1UL * this->_internal_boxes__size();
  for (const auto& msg : this->boxes__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Attributes attributes_ = 6;
  total_size += 1UL * this->_internal_attributes__size();
  for (const auto& msg : this->attributes__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Points points_ = 7;
  total_size += 1UL * this->_internal_points__size();
  for (const auto& msg : this->points__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.FloatArray float_arrays_ = 8;
  total_size += 1UL * this->_internal_float_arrays__size();
  for (const auto& msg : this->float_arrays__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.FloatMatrix float_matrixs_ = 9;
  total_size += 1UL * this->_internal_float_matrixs__size();
  for (const auto& msg : this->float_matrixs__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.CharArray char_arrays_ = 10;
  total_size += 1UL * this->_internal_char_arrays__size();
  for (const auto& msg : this->char_arrays__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint64 track_id_ = 2;
  if (this->_internal_track_id_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_id_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Target::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Target*>(
      &from));
}

void Target::MergeFrom(const Target& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Target)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  imgs__.MergeFrom(from.imgs__);
  sub_targets__.MergeFrom(from.sub_targets__);
  boxes__.MergeFrom(from.boxes__);
  attributes__.MergeFrom(from.attributes__);
  points__.MergeFrom(from.points__);
  float_arrays__.MergeFrom(from.float_arrays__);
  float_matrixs__.MergeFrom(from.float_matrixs__);
  char_arrays__.MergeFrom(from.char_arrays__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_track_id_() != 0) {
    _internal_set_track_id_(from._internal_track_id_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Target::CopyFrom(const Target& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Target)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Target::IsInitialized() const {
  return true;
}

void Target::InternalSwap(Target* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  imgs__.InternalSwap(&other->imgs__);
  sub_targets__.InternalSwap(&other->sub_targets__);
  boxes__.InternalSwap(&other->boxes__);
  attributes__.InternalSwap(&other->attributes__);
  points__.InternalSwap(&other->points__);
  float_arrays__.InternalSwap(&other->float_arrays__);
  float_matrixs__.InternalSwap(&other->float_matrixs__);
  char_arrays__.InternalSwap(&other->char_arrays__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(track_id__, other->track_id__);
}

std::string Target::GetTypeName() const {
  return "x3.Target";
}


// ===================================================================

class SmartFrameMessage::_Internal {
 public:
};

SmartFrameMessage::SmartFrameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targets__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.SmartFrameMessage)
}
SmartFrameMessage::SmartFrameMessage(const SmartFrameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targets__(from.targets__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp__, &from.timestamp__,
    static_cast<size_t>(reinterpret_cast<char*>(&error_code__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(error_code__));
  // @@protoc_insertion_point(copy_constructor:x3.SmartFrameMessage)
}

inline void SmartFrameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(error_code__));
}

SmartFrameMessage::~SmartFrameMessage() {
  // @@protoc_insertion_point(destructor:x3.SmartFrameMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartFrameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SmartFrameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SmartFrameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.SmartFrameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets__.Clear();
  ::memset(&timestamp__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&error_code__) -
      reinterpret_cast<char*>(&timestamp__)) + sizeof(error_code__));
  _internal_metadata_.Clear<std::string>();
}

const char* SmartFrameMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 timestamp_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 error_code_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          error_code__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Target targets_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_targets_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartFrameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.SmartFrameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 timestamp_ = 1;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_timestamp_(), target);
  }

  // uint32 error_code_ = 2;
  if (this->_internal_error_code_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_error_code_(), target);
  }

  // repeated .x3.Target targets_ = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_targets__size()); i < n; i++) {
    const auto& repfield = this->_internal_targets_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.SmartFrameMessage)
  return target;
}

size_t SmartFrameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.SmartFrameMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Target targets_ = 3;
  total_size += 1UL * this->_internal_targets__size();
  for (const auto& msg : this->targets__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // fixed64 timestamp_ = 1;
  if (this->_internal_timestamp_() != 0) {
    total_size += 1 + 8;
  }

  // uint32 error_code_ = 2;
  if (this->_internal_error_code_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SmartFrameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SmartFrameMessage*>(
      &from));
}

void SmartFrameMessage::MergeFrom(const SmartFrameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.SmartFrameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets__.MergeFrom(from.targets__);
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_error_code_() != 0) {
    _internal_set_error_code_(from._internal_error_code_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SmartFrameMessage::CopyFrom(const SmartFrameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.SmartFrameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartFrameMessage::IsInitialized() const {
  return true;
}

void SmartFrameMessage::InternalSwap(SmartFrameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets__.InternalSwap(&other->targets__);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartFrameMessage, error_code__)
      + sizeof(SmartFrameMessage::error_code__)
      - PROTOBUF_FIELD_OFFSET(SmartFrameMessage, timestamp__)>(
          reinterpret_cast<char*>(&timestamp__),
          reinterpret_cast<char*>(&other->timestamp__));
}

std::string SmartFrameMessage::GetTypeName() const {
  return "x3.SmartFrameMessage";
}


// ===================================================================

class Capture::_Internal {
 public:
  static const ::x3::Image& img_(const Capture* msg);
};

const ::x3::Image&
Capture::_Internal::img_(const Capture* msg) {
  return *msg->img__;
}
Capture::Capture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  boxes__(arena),
  attributes__(arena),
  points__(arena),
  float_arrays__(arena),
  char_arrays__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Capture)
}
Capture::Capture(const Capture& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      boxes__(from.boxes__),
      attributes__(from.attributes__),
      points__(from.points__),
      float_arrays__(from.float_arrays__),
      char_arrays__(from.char_arrays__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_img_()) {
    img__ = new ::x3::Image(*from.img__);
  } else {
    img__ = nullptr;
  }
  timestamp__ = from.timestamp__;
  // @@protoc_insertion_point(copy_constructor:x3.Capture)
}

inline void Capture::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&img__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp__) -
    reinterpret_cast<char*>(&img__)) + sizeof(timestamp__));
}

Capture::~Capture() {
  // @@protoc_insertion_point(destructor:x3.Capture)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Capture::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  if (this != internal_default_instance()) delete img__;
}

void Capture::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Capture::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Capture)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  boxes__.Clear();
  attributes__.Clear();
  points__.Clear();
  float_arrays__.Clear();
  char_arrays__.Clear();
  type__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && img__ != nullptr) {
    delete img__;
  }
  img__ = nullptr;
  timestamp__ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* Capture::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // fixed64 timestamp_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // .x3.Image img_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_img_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Box boxes_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_boxes_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Attributes attributes_ = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attributes_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Points points_ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.FloatArray float_arrays_ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_float_arrays_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.CharArray char_arrays_ = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_char_arrays_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Capture::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Capture)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Capture.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // fixed64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_timestamp_(), target);
  }

  // .x3.Image img_ = 3;
  if (this->_internal_has_img_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::img_(this),
        _Internal::img_(this).GetCachedSize(), target, stream);
  }

  // repeated .x3.Box boxes_ = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_boxes__size()); i < n; i++) {
    const auto& repfield = this->_internal_boxes_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Attributes attributes_ = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributes__size()); i < n; i++) {
    const auto& repfield = this->_internal_attributes_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Points points_ = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points__size()); i < n; i++) {
    const auto& repfield = this->_internal_points_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.FloatArray float_arrays_ = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_float_arrays__size()); i < n; i++) {
    const auto& repfield = this->_internal_float_arrays_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.CharArray char_arrays_ = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_char_arrays__size()); i < n; i++) {
    const auto& repfield = this->_internal_char_arrays_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Capture)
  return target;
}

size_t Capture::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Capture)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Box boxes_ = 4;
  total_size += 1UL * this->_internal_boxes__size();
  for (const auto& msg : this->boxes__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Attributes attributes_ = 5;
  total_size += 1UL * this->_internal_attributes__size();
  for (const auto& msg : this->attributes__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Points points_ = 6;
  total_size += 1UL * this->_internal_points__size();
  for (const auto& msg : this->points__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.FloatArray float_arrays_ = 7;
  total_size += 1UL * this->_internal_float_arrays__size();
  for (const auto& msg : this->float_arrays__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.CharArray char_arrays_ = 8;
  total_size += 1UL * this->_internal_char_arrays__size();
  for (const auto& msg : this->char_arrays__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // .x3.Image img_ = 3;
  if (this->_internal_has_img_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *img__);
  }

  // fixed64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Capture::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Capture*>(
      &from));
}

void Capture::MergeFrom(const Capture& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Capture)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  boxes__.MergeFrom(from.boxes__);
  attributes__.MergeFrom(from.attributes__);
  points__.MergeFrom(from.points__);
  float_arrays__.MergeFrom(from.float_arrays__);
  char_arrays__.MergeFrom(from.char_arrays__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_has_img_()) {
    _internal_mutable_img_()->::x3::Image::MergeFrom(from._internal_img_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Capture::CopyFrom(const Capture& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Capture)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Capture::IsInitialized() const {
  return true;
}

void Capture::InternalSwap(Capture* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  boxes__.InternalSwap(&other->boxes__);
  attributes__.InternalSwap(&other->attributes__);
  points__.InternalSwap(&other->points__);
  float_arrays__.InternalSwap(&other->float_arrays__);
  char_arrays__.InternalSwap(&other->char_arrays__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Capture, timestamp__)
      + sizeof(Capture::timestamp__)
      - PROTOBUF_FIELD_OFFSET(Capture, img__)>(
          reinterpret_cast<char*>(&img__),
          reinterpret_cast<char*>(&other->img__));
}

std::string Capture::GetTypeName() const {
  return "x3.Capture";
}


// ===================================================================

class CaptureTarget::_Internal {
 public:
};

CaptureTarget::CaptureTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  captures__(arena),
  db_results__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.CaptureTarget)
}
CaptureTarget::CaptureTarget(const CaptureTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      captures__(from.captures__),
      db_results__(from.db_results__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  track_id__ = from.track_id__;
  // @@protoc_insertion_point(copy_constructor:x3.CaptureTarget)
}

inline void CaptureTarget::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
track_id__ = uint64_t{0u};
}

CaptureTarget::~CaptureTarget() {
  // @@protoc_insertion_point(destructor:x3.CaptureTarget)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void CaptureTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CaptureTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.CaptureTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  captures__.Clear();
  db_results__.Clear();
  type__.ClearToEmpty();
  track_id__ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* CaptureTarget::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 track_id_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          track_id__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Capture captures_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_captures_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.DBResult db_results_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_db_results_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.CaptureTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.CaptureTarget.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // uint64 track_id_ = 2;
  if (this->_internal_track_id_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_track_id_(), target);
  }

  // repeated .x3.Capture captures_ = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_captures__size()); i < n; i++) {
    const auto& repfield = this->_internal_captures_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.DBResult db_results_ = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_db_results__size()); i < n; i++) {
    const auto& repfield = this->_internal_db_results_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.CaptureTarget)
  return target;
}

size_t CaptureTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.CaptureTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Capture captures_ = 3;
  total_size += 1UL * this->_internal_captures__size();
  for (const auto& msg : this->captures__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.DBResult db_results_ = 4;
  total_size += 1UL * this->_internal_db_results__size();
  for (const auto& msg : this->db_results__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint64 track_id_ = 2;
  if (this->_internal_track_id_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_id_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CaptureTarget::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CaptureTarget*>(
      &from));
}

void CaptureTarget::MergeFrom(const CaptureTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.CaptureTarget)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  captures__.MergeFrom(from.captures__);
  db_results__.MergeFrom(from.db_results__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_track_id_() != 0) {
    _internal_set_track_id_(from._internal_track_id_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CaptureTarget::CopyFrom(const CaptureTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.CaptureTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureTarget::IsInitialized() const {
  return true;
}

void CaptureTarget::InternalSwap(CaptureTarget* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  captures__.InternalSwap(&other->captures__);
  db_results__.InternalSwap(&other->db_results__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(track_id__, other->track_id__);
}

std::string CaptureTarget::GetTypeName() const {
  return "x3.CaptureTarget";
}


// ===================================================================

class CaptureFrameMessage::_Internal {
 public:
};

CaptureFrameMessage::CaptureFrameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targets__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.CaptureFrameMessage)
}
CaptureFrameMessage::CaptureFrameMessage(const CaptureFrameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targets__(from.targets__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:x3.CaptureFrameMessage)
}

inline void CaptureFrameMessage::SharedCtor() {
}

CaptureFrameMessage::~CaptureFrameMessage() {
  // @@protoc_insertion_point(destructor:x3.CaptureFrameMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureFrameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CaptureFrameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CaptureFrameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.CaptureFrameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets__.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CaptureFrameMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .x3.CaptureTarget targets_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_targets_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureFrameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.CaptureFrameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .x3.CaptureTarget targets_ = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_targets__size()); i < n; i++) {
    const auto& repfield = this->_internal_targets_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.CaptureFrameMessage)
  return target;
}

size_t CaptureFrameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.CaptureFrameMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.CaptureTarget targets_ = 1;
  total_size += 1UL * this->_internal_targets__size();
  for (const auto& msg : this->targets__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CaptureFrameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CaptureFrameMessage*>(
      &from));
}

void CaptureFrameMessage::MergeFrom(const CaptureFrameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.CaptureFrameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets__.MergeFrom(from.targets__);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CaptureFrameMessage::CopyFrom(const CaptureFrameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.CaptureFrameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureFrameMessage::IsInitialized() const {
  return true;
}

void CaptureFrameMessage::InternalSwap(CaptureFrameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets__.InternalSwap(&other->targets__);
}

std::string CaptureFrameMessage::GetTypeName() const {
  return "x3.CaptureFrameMessage";
}


// ===================================================================

class StatisticsMessage::_Internal {
 public:
};

StatisticsMessage::StatisticsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  attributes__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.StatisticsMessage)
}
StatisticsMessage::StatisticsMessage(const StatisticsMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      attributes__(from.attributes__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:x3.StatisticsMessage)
}

inline void StatisticsMessage::SharedCtor() {
}

StatisticsMessage::~StatisticsMessage() {
  // @@protoc_insertion_point(destructor:x3.StatisticsMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatisticsMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatisticsMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatisticsMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.StatisticsMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  attributes__.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatisticsMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .x3.Attributes attributes_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attributes_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatisticsMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.StatisticsMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .x3.Attributes attributes_ = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributes__size()); i < n; i++) {
    const auto& repfield = this->_internal_attributes_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.StatisticsMessage)
  return target;
}

size_t StatisticsMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.StatisticsMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Attributes attributes_ = 1;
  total_size += 1UL * this->_internal_attributes__size();
  for (const auto& msg : this->attributes__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatisticsMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StatisticsMessage*>(
      &from));
}

void StatisticsMessage::MergeFrom(const StatisticsMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.StatisticsMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  attributes__.MergeFrom(from.attributes__);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatisticsMessage::CopyFrom(const StatisticsMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.StatisticsMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatisticsMessage::IsInitialized() const {
  return true;
}

void StatisticsMessage::InternalSwap(StatisticsMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  attributes__.InternalSwap(&other->attributes__);
}

std::string StatisticsMessage::GetTypeName() const {
  return "x3.StatisticsMessage";
}


// ===================================================================

class FrameMessage::_Internal {
 public:
  static const ::x3::SmartFrameMessage& smart_msg_(const FrameMessage* msg);
  static const ::x3::CaptureFrameMessage& capture_msg_(const FrameMessage* msg);
  static const ::x3::StatisticsMessage& statistics_msg_(const FrameMessage* msg);
  static const ::x3::Image& img_(const FrameMessage* msg);
};

const ::x3::SmartFrameMessage&
FrameMessage::_Internal::smart_msg_(const FrameMessage* msg) {
  return *msg->smart_msg__;
}
const ::x3::CaptureFrameMessage&
FrameMessage::_Internal::capture_msg_(const FrameMessage* msg) {
  return *msg->capture_msg__;
}
const ::x3::StatisticsMessage&
FrameMessage::_Internal::statistics_msg_(const FrameMessage* msg) {
  return *msg->statistics_msg__;
}
const ::x3::Image&
FrameMessage::_Internal::img_(const FrameMessage* msg) {
  return *msg->img__;
}
FrameMessage::FrameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  extimgs__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.FrameMessage)
}
FrameMessage::FrameMessage(const FrameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      extimgs__(from.extimgs__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_smart_msg_()) {
    smart_msg__ = new ::x3::SmartFrameMessage(*from.smart_msg__);
  } else {
    smart_msg__ = nullptr;
  }
  if (from._internal_has_capture_msg_()) {
    capture_msg__ = new ::x3::CaptureFrameMessage(*from.capture_msg__);
  } else {
    capture_msg__ = nullptr;
  }
  if (from._internal_has_statistics_msg_()) {
    statistics_msg__ = new ::x3::StatisticsMessage(*from.statistics_msg__);
  } else {
    statistics_msg__ = nullptr;
  }
  if (from._internal_has_img_()) {
    img__ = new ::x3::Image(*from.img__);
  } else {
    img__ = nullptr;
  }
  ::memcpy(&timestamp__, &from.timestamp__,
    static_cast<size_t>(reinterpret_cast<char*>(&sequence_id__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(sequence_id__));
  // @@protoc_insertion_point(copy_constructor:x3.FrameMessage)
}

inline void FrameMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&smart_msg__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sequence_id__) -
    reinterpret_cast<char*>(&smart_msg__)) + sizeof(sequence_id__));
}

FrameMessage::~FrameMessage() {
  // @@protoc_insertion_point(destructor:x3.FrameMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete smart_msg__;
  if (this != internal_default_instance()) delete capture_msg__;
  if (this != internal_default_instance()) delete statistics_msg__;
  if (this != internal_default_instance()) delete img__;
}

void FrameMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.FrameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  extimgs__.Clear();
  if (GetArenaForAllocation() == nullptr && smart_msg__ != nullptr) {
    delete smart_msg__;
  }
  smart_msg__ = nullptr;
  if (GetArenaForAllocation() == nullptr && capture_msg__ != nullptr) {
    delete capture_msg__;
  }
  capture_msg__ = nullptr;
  if (GetArenaForAllocation() == nullptr && statistics_msg__ != nullptr) {
    delete statistics_msg__;
  }
  statistics_msg__ = nullptr;
  if (GetArenaForAllocation() == nullptr && img__ != nullptr) {
    delete img__;
  }
  img__ = nullptr;
  ::memset(&timestamp__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sequence_id__) -
      reinterpret_cast<char*>(&timestamp__)) + sizeof(sequence_id__));
  _internal_metadata_.Clear<std::string>();
}

const char* FrameMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .x3.SmartFrameMessage smart_msg_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_smart_msg_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.CaptureFrameMessage capture_msg_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_capture_msg_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.StatisticsMessage Statistics_msg_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_statistics_msg_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Image img_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_img_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 timestamp_ = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // uint64 sequence_id_ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          sequence_id__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Image extimgs_ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extimgs_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.FrameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .x3.SmartFrameMessage smart_msg_ = 1;
  if (this->_internal_has_smart_msg_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::smart_msg_(this),
        _Internal::smart_msg_(this).GetCachedSize(), target, stream);
  }

  // .x3.CaptureFrameMessage capture_msg_ = 2;
  if (this->_internal_has_capture_msg_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::capture_msg_(this),
        _Internal::capture_msg_(this).GetCachedSize(), target, stream);
  }

  // .x3.StatisticsMessage Statistics_msg_ = 3;
  if (this->_internal_has_statistics_msg_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::statistics_msg_(this),
        _Internal::statistics_msg_(this).GetCachedSize(), target, stream);
  }

  // .x3.Image img_ = 4;
  if (this->_internal_has_img_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::img_(this),
        _Internal::img_(this).GetCachedSize(), target, stream);
  }

  // fixed64 timestamp_ = 5;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(5, this->_internal_timestamp_(), target);
  }

  // uint64 sequence_id_ = 6;
  if (this->_internal_sequence_id_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_sequence_id_(), target);
  }

  // repeated .x3.Image extimgs_ = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extimgs__size()); i < n; i++) {
    const auto& repfield = this->_internal_extimgs_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.FrameMessage)
  return target;
}

size_t FrameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.FrameMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Image extimgs_ = 7;
  total_size += 1UL * this->_internal_extimgs__size();
  for (const auto& msg : this->extimgs__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .x3.SmartFrameMessage smart_msg_ = 1;
  if (this->_internal_has_smart_msg_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *smart_msg__);
  }

  // .x3.CaptureFrameMessage capture_msg_ = 2;
  if (this->_internal_has_capture_msg_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *capture_msg__);
  }

  // .x3.StatisticsMessage Statistics_msg_ = 3;
  if (this->_internal_has_statistics_msg_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *statistics_msg__);
  }

  // .x3.Image img_ = 4;
  if (this->_internal_has_img_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *img__);
  }

  // fixed64 timestamp_ = 5;
  if (this->_internal_timestamp_() != 0) {
    total_size += 1 + 8;
  }

  // uint64 sequence_id_ = 6;
  if (this->_internal_sequence_id_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sequence_id_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FrameMessage*>(
      &from));
}

void FrameMessage::MergeFrom(const FrameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.FrameMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  extimgs__.MergeFrom(from.extimgs__);
  if (from._internal_has_smart_msg_()) {
    _internal_mutable_smart_msg_()->::x3::SmartFrameMessage::MergeFrom(from._internal_smart_msg_());
  }
  if (from._internal_has_capture_msg_()) {
    _internal_mutable_capture_msg_()->::x3::CaptureFrameMessage::MergeFrom(from._internal_capture_msg_());
  }
  if (from._internal_has_statistics_msg_()) {
    _internal_mutable_statistics_msg_()->::x3::StatisticsMessage::MergeFrom(from._internal_statistics_msg_());
  }
  if (from._internal_has_img_()) {
    _internal_mutable_img_()->::x3::Image::MergeFrom(from._internal_img_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_sequence_id_() != 0) {
    _internal_set_sequence_id_(from._internal_sequence_id_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FrameMessage::CopyFrom(const FrameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.FrameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameMessage::IsInitialized() const {
  return true;
}

void FrameMessage::InternalSwap(FrameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  extimgs__.InternalSwap(&other->extimgs__);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameMessage, sequence_id__)
      + sizeof(FrameMessage::sequence_id__)
      - PROTOBUF_FIELD_OFFSET(FrameMessage, smart_msg__)>(
          reinterpret_cast<char*>(&smart_msg__),
          reinterpret_cast<char*>(&other->smart_msg__));
}

std::string FrameMessage::GetTypeName() const {
  return "x3.FrameMessage";
}


// ===================================================================

class Capability::_Internal {
 public:
  static const ::x3::Enable& cap_array_(const Capability* msg);
};

const ::x3::Enable&
Capability::_Internal::cap_array_(const Capability* msg) {
  return *msg->cap_array__;
}
Capability::Capability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Capability)
}
Capability::Capability(const Capability& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_cap_array_()) {
    cap_array__ = new ::x3::Enable(*from.cap_array__);
  } else {
    cap_array__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:x3.Capability)
}

inline void Capability::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cap_array__ = nullptr;
}

Capability::~Capability() {
  // @@protoc_insertion_point(destructor:x3.Capability)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Capability::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  if (this != internal_default_instance()) delete cap_array__;
}

void Capability::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Capability::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Capability)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && cap_array__ != nullptr) {
    delete cap_array__;
  }
  cap_array__ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* Capability::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .x3.Enable cap_array_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cap_array_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Capability::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Capability)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Capability.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // .x3.Enable cap_array_ = 2;
  if (this->_internal_has_cap_array_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cap_array_(this),
        _Internal::cap_array_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Capability)
  return target;
}

size_t Capability::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Capability)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // .x3.Enable cap_array_ = 2;
  if (this->_internal_has_cap_array_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cap_array__);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Capability::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Capability*>(
      &from));
}

void Capability::MergeFrom(const Capability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Capability)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_has_cap_array_()) {
    _internal_mutable_cap_array_()->::x3::Enable::MergeFrom(from._internal_cap_array_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Capability::CopyFrom(const Capability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Capability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Capability::IsInitialized() const {
  return true;
}

void Capability::InternalSwap(Capability* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(cap_array__, other->cap_array__);
}

std::string Capability::GetTypeName() const {
  return "x3.Capability";
}


// ===================================================================

class Version::_Internal {
 public:
};

Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  value__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value_().empty()) {
    value__.Set(from._internal_value_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.Version)
}

inline void Version::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:x3.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
  value__.Destroy();
}

void Version::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  value__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string value_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Version.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // string value_ = 2;
  if (!this->_internal_value_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value_().data(), static_cast<int>(this->_internal_value_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Version.value_");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Version)
  return target;
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // string value_ = 2;
  if (!this->_internal_value_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Version::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Version*>(
      &from));
}

void Version::MergeFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Version)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (!from._internal_value_().empty()) {
    _internal_set_value_(from._internal_value_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value__, lhs_arena,
      &other->value__, rhs_arena
  );
}

std::string Version::GetTypeName() const {
  return "x3.Version";
}


// ===================================================================

class Config::_Internal {
 public:
};

Config::Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  threshold__(arena),
  mode__(arena),
  shield__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Config)
}
Config::Config(const Config& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      threshold__(from.threshold__),
      mode__(from.mode__),
      shield__(from.shield__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:x3.Config)
}

inline void Config::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:x3.Config)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Config::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Config::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Config::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Config)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threshold__.Clear();
  mode__.Clear();
  shield__.Clear();
  type__.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Config::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Threshold threshold_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threshold_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Mode mode_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mode_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Box shield_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shield_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Config::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Config)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Config.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // repeated .x3.Threshold threshold_ = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threshold__size()); i < n; i++) {
    const auto& repfield = this->_internal_threshold_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Mode mode_ = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mode__size()); i < n; i++) {
    const auto& repfield = this->_internal_mode_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Box shield_ = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shield__size()); i < n; i++) {
    const auto& repfield = this->_internal_shield_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Config)
  return target;
}

size_t Config::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Config)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Threshold threshold_ = 2;
  total_size += 1UL * this->_internal_threshold__size();
  for (const auto& msg : this->threshold__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Mode mode_ = 3;
  total_size += 1UL * this->_internal_mode__size();
  for (const auto& msg : this->mode__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Box shield_ = 4;
  total_size += 1UL * this->_internal_shield__size();
  for (const auto& msg : this->shield__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Config::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Config*>(
      &from));
}

void Config::MergeFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Config)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  threshold__.MergeFrom(from.threshold__);
  mode__.MergeFrom(from.mode__);
  shield__.MergeFrom(from.shield__);
  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Config::CopyFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {
  return true;
}

void Config::InternalSwap(Config* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  threshold__.InternalSwap(&other->threshold__);
  mode__.InternalSwap(&other->mode__);
  shield__.InternalSwap(&other->shield__);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
}

std::string Config::GetTypeName() const {
  return "x3.Config";
}


// ===================================================================

class Status::_Internal {
 public:
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp__, &from.timestamp__,
    static_cast<size_t>(reinterpret_cast<char*>(&run_status__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(run_status__));
  // @@protoc_insertion_point(copy_constructor:x3.Status)
}

inline void Status::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&run_status__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(run_status__));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:x3.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Status::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  ::memset(&timestamp__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&run_status__) -
      reinterpret_cast<char*>(&timestamp__)) + sizeof(run_status__));
  _internal_metadata_.Clear<std::string>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Status.RunStatus run_status_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_run_status_(static_cast<::x3::Status_RunStatus>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Status.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp_(), target);
  }

  // .x3.Status.RunStatus run_status_ = 3;
  if (this->_internal_run_status_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_run_status_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp_());
  }

  // .x3.Status.RunStatus run_status_ = 3;
  if (this->_internal_run_status_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_run_status_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Status::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Status*>(
      &from));
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Status)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_run_status_() != 0) {
    _internal_set_run_status_(from._internal_run_status_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, run_status__)
      + sizeof(Status::run_status__)
      - PROTOBUF_FIELD_OFFSET(Status, timestamp__)>(
          reinterpret_cast<char*>(&timestamp__),
          reinterpret_cast<char*>(&other->timestamp__));
}

std::string Status::GetTypeName() const {
  return "x3.Status";
}


// ===================================================================

class Command::_Internal {
 public:
};

Command::Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Command)
}
Command::Command(const Command& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp__, &from.timestamp__,
    static_cast<size_t>(reinterpret_cast<char*>(&order__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(order__));
  // @@protoc_insertion_point(copy_constructor:x3.Command)
}

inline void Command::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&order__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(order__));
}

Command::~Command() {
  // @@protoc_insertion_point(destructor:x3.Command)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Command::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Command::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Command::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Command)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  ::memset(&timestamp__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&order__) -
      reinterpret_cast<char*>(&timestamp__)) + sizeof(order__));
  _internal_metadata_.Clear<std::string>();
}

const char* Command::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Command.Order order_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_order_(static_cast<::x3::Command_Order>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Command::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Command)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Command.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp_(), target);
  }

  // .x3.Command.Order order_ = 3;
  if (this->_internal_order_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_order_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Command)
  return target;
}

size_t Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Command)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp_());
  }

  // .x3.Command.Order order_ = 3;
  if (this->_internal_order_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_order_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Command::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Command*>(
      &from));
}

void Command::MergeFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Command)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_order_() != 0) {
    _internal_set_order_(from._internal_order_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Command::CopyFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Command::IsInitialized() const {
  return true;
}

void Command::InternalSwap(Command* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Command, order__)
      + sizeof(Command::order__)
      - PROTOBUF_FIELD_OFFSET(Command, timestamp__)>(
          reinterpret_cast<char*>(&timestamp__),
          reinterpret_cast<char*>(&other->timestamp__));
}

std::string Command::GetTypeName() const {
  return "x3.Command";
}


// ===================================================================

class Response::_Internal {
 public:
};

Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp__, &from.timestamp__,
    static_cast<size_t>(reinterpret_cast<char*>(&ack__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(ack__));
  // @@protoc_insertion_point(copy_constructor:x3.Response)
}

inline void Response::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ack__) -
    reinterpret_cast<char*>(&timestamp__)) + sizeof(ack__));
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:x3.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  ::memset(&timestamp__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ack__) -
      reinterpret_cast<char*>(&timestamp__)) + sizeof(ack__));
  _internal_metadata_.Clear<std::string>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Response.Ack ack_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ack_(static_cast<::x3::Response_Ack>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.Response.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp_(), target);
  }

  // .x3.Response.Ack ack_ = 3;
  if (this->_internal_ack_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_ack_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp_());
  }

  // .x3.Response.Ack ack_ = 3;
  if (this->_internal_ack_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_ack_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Response*>(
      &from));
}

void Response::MergeFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_ack_() != 0) {
    _internal_set_ack_(from._internal_ack_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Response, ack__)
      + sizeof(Response::ack__)
      - PROTOBUF_FIELD_OFFSET(Response, timestamp__)>(
          reinterpret_cast<char*>(&timestamp__),
          reinterpret_cast<char*>(&other->timestamp__));
}

std::string Response::GetTypeName() const {
  return "x3.Response";
}


// ===================================================================

class LogLevel::_Internal {
 public:
};

LogLevel::LogLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.LogLevel)
}
LogLevel::LogLevel(const LogLevel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type_().empty()) {
    type__.Set(from._internal_type_(), 
      GetArenaForAllocation());
  }
  level__ = from.level__;
  // @@protoc_insertion_point(copy_constructor:x3.LogLevel)
}

inline void LogLevel::SharedCtor() {
type__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
level__ = 0;
}

LogLevel::~LogLevel() {
  // @@protoc_insertion_point(destructor:x3.LogLevel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogLevel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type__.Destroy();
}

void LogLevel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogLevel::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.LogLevel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type__.ClearToEmpty();
  level__ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* LogLevel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .x3.LogLevel.Level level_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level_(static_cast<::x3::LogLevel_Level>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogLevel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.LogLevel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type_().data(), static_cast<int>(this->_internal_type_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "x3.LogLevel.type_");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_(), target);
  }

  // .x3.LogLevel.Level level_ = 2;
  if (this->_internal_level_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_level_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.LogLevel)
  return target;
}

size_t LogLevel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.LogLevel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type_ = 1;
  if (!this->_internal_type_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type_());
  }

  // .x3.LogLevel.Level level_ = 2;
  if (this->_internal_level_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogLevel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LogLevel*>(
      &from));
}

void LogLevel::MergeFrom(const LogLevel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.LogLevel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type_().empty()) {
    _internal_set_type_(from._internal_type_());
  }
  if (from._internal_level_() != 0) {
    _internal_set_level_(from._internal_level_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogLevel::CopyFrom(const LogLevel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.LogLevel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogLevel::IsInitialized() const {
  return true;
}

void LogLevel::InternalSwap(LogLevel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type__, lhs_arena,
      &other->type__, rhs_arena
  );
  swap(level__, other->level__);
}

std::string LogLevel::GetTypeName() const {
  return "x3.LogLevel";
}


// ===================================================================

class InfoMessage::_Internal {
 public:
  static const ::x3::Status& status_(const InfoMessage* msg);
  static const ::x3::Command& command_(const InfoMessage* msg);
  static const ::x3::LogLevel& loglevel_(const InfoMessage* msg);
  static const ::x3::Response& response_(const InfoMessage* msg);
};

const ::x3::Status&
InfoMessage::_Internal::status_(const InfoMessage* msg) {
  return *msg->status__;
}
const ::x3::Command&
InfoMessage::_Internal::command_(const InfoMessage* msg) {
  return *msg->command__;
}
const ::x3::LogLevel&
InfoMessage::_Internal::loglevel_(const InfoMessage* msg) {
  return *msg->loglevel__;
}
const ::x3::Response&
InfoMessage::_Internal::response_(const InfoMessage* msg) {
  return *msg->response__;
}
InfoMessage::InfoMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  config__(arena),
  version__(arena),
  capability__(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.InfoMessage)
}
InfoMessage::InfoMessage(const InfoMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      config__(from.config__),
      version__(from.version__),
      capability__(from.capability__) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status_()) {
    status__ = new ::x3::Status(*from.status__);
  } else {
    status__ = nullptr;
  }
  if (from._internal_has_command_()) {
    command__ = new ::x3::Command(*from.command__);
  } else {
    command__ = nullptr;
  }
  if (from._internal_has_loglevel_()) {
    loglevel__ = new ::x3::LogLevel(*from.loglevel__);
  } else {
    loglevel__ = nullptr;
  }
  if (from._internal_has_response_()) {
    response__ = new ::x3::Response(*from.response__);
  } else {
    response__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:x3.InfoMessage)
}

inline void InfoMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&status__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&response__) -
    reinterpret_cast<char*>(&status__)) + sizeof(response__));
}

InfoMessage::~InfoMessage() {
  // @@protoc_insertion_point(destructor:x3.InfoMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status__;
  if (this != internal_default_instance()) delete command__;
  if (this != internal_default_instance()) delete loglevel__;
  if (this != internal_default_instance()) delete response__;
}

void InfoMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.InfoMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  config__.Clear();
  version__.Clear();
  capability__.Clear();
  if (GetArenaForAllocation() == nullptr && status__ != nullptr) {
    delete status__;
  }
  status__ = nullptr;
  if (GetArenaForAllocation() == nullptr && command__ != nullptr) {
    delete command__;
  }
  command__ = nullptr;
  if (GetArenaForAllocation() == nullptr && loglevel__ != nullptr) {
    delete loglevel__;
  }
  loglevel__ = nullptr;
  if (GetArenaForAllocation() == nullptr && response__ != nullptr) {
    delete response__;
  }
  response__ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* InfoMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .x3.Status status_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Command command_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.LogLevel loglevel_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_loglevel_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Response response_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Config config_ = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_config_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Version version_ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_version_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .x3.Capability capability_ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_capability_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.InfoMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .x3.Status status_ = 1;
  if (this->_internal_has_status_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status_(this),
        _Internal::status_(this).GetCachedSize(), target, stream);
  }

  // .x3.Command command_ = 2;
  if (this->_internal_has_command_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::command_(this),
        _Internal::command_(this).GetCachedSize(), target, stream);
  }

  // .x3.LogLevel loglevel_ = 3;
  if (this->_internal_has_loglevel_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::loglevel_(this),
        _Internal::loglevel_(this).GetCachedSize(), target, stream);
  }

  // .x3.Response response_ = 4;
  if (this->_internal_has_response_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::response_(this),
        _Internal::response_(this).GetCachedSize(), target, stream);
  }

  // repeated .x3.Config config_ = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_config__size()); i < n; i++) {
    const auto& repfield = this->_internal_config_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Version version_ = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_version__size()); i < n; i++) {
    const auto& repfield = this->_internal_version_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .x3.Capability capability_ = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_capability__size()); i < n; i++) {
    const auto& repfield = this->_internal_capability_(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.InfoMessage)
  return target;
}

size_t InfoMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.InfoMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .x3.Config config_ = 5;
  total_size += 1UL * this->_internal_config__size();
  for (const auto& msg : this->config__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Version version_ = 6;
  total_size += 1UL * this->_internal_version__size();
  for (const auto& msg : this->version__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .x3.Capability capability_ = 7;
  total_size += 1UL * this->_internal_capability__size();
  for (const auto& msg : this->capability__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .x3.Status status_ = 1;
  if (this->_internal_has_status_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status__);
  }

  // .x3.Command command_ = 2;
  if (this->_internal_has_command_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *command__);
  }

  // .x3.LogLevel loglevel_ = 3;
  if (this->_internal_has_loglevel_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *loglevel__);
  }

  // .x3.Response response_ = 4;
  if (this->_internal_has_response_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *response__);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoMessage*>(
      &from));
}

void InfoMessage::MergeFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.InfoMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  config__.MergeFrom(from.config__);
  version__.MergeFrom(from.version__);
  capability__.MergeFrom(from.capability__);
  if (from._internal_has_status_()) {
    _internal_mutable_status_()->::x3::Status::MergeFrom(from._internal_status_());
  }
  if (from._internal_has_command_()) {
    _internal_mutable_command_()->::x3::Command::MergeFrom(from._internal_command_());
  }
  if (from._internal_has_loglevel_()) {
    _internal_mutable_loglevel_()->::x3::LogLevel::MergeFrom(from._internal_loglevel_());
  }
  if (from._internal_has_response_()) {
    _internal_mutable_response_()->::x3::Response::MergeFrom(from._internal_response_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoMessage::CopyFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.InfoMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoMessage::IsInitialized() const {
  return true;
}

void InfoMessage::InternalSwap(InfoMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  config__.InternalSwap(&other->config__);
  version__.InternalSwap(&other->version__);
  capability__.InternalSwap(&other->capability__);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InfoMessage, response__)
      + sizeof(InfoMessage::response__)
      - PROTOBUF_FIELD_OFFSET(InfoMessage, status__)>(
          reinterpret_cast<char*>(&status__),
          reinterpret_cast<char*>(&other->status__));
}

std::string InfoMessage::GetTypeName() const {
  return "x3.InfoMessage";
}


// ===================================================================

class Frame::_Internal {
 public:
};

Frame::Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&sequence_id__, &from.sequence_id__,
    static_cast<size_t>(reinterpret_cast<char*>(&frame_type__) -
    reinterpret_cast<char*>(&sequence_id__)) + sizeof(frame_type__));
  // @@protoc_insertion_point(copy_constructor:x3.Frame)
}

inline void Frame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sequence_id__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_type__) -
    reinterpret_cast<char*>(&sequence_id__)) + sizeof(frame_type__));
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:x3.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&sequence_id__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&frame_type__) -
      reinterpret_cast<char*>(&sequence_id__)) + sizeof(frame_type__));
  _internal_metadata_.Clear<std::string>();
}

const char* Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 sequence_id_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          sequence_id__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          timestamp__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Frame.FrameType frame_type_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_frame_type_(static_cast<::x3::Frame_FrameType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 sequence_id_ = 1;
  if (this->_internal_sequence_id_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sequence_id_(), target);
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_timestamp_(), target);
  }

  // .x3.Frame.FrameType frame_type_ = 3;
  if (this->_internal_frame_type_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_frame_type_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 sequence_id_ = 1;
  if (this->_internal_sequence_id_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sequence_id_());
  }

  // uint64 timestamp_ = 2;
  if (this->_internal_timestamp_() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp_());
  }

  // .x3.Frame.FrameType frame_type_ = 3;
  if (this->_internal_frame_type_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_frame_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Frame*>(
      &from));
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sequence_id_() != 0) {
    _internal_set_sequence_id_(from._internal_sequence_id_());
  }
  if (from._internal_timestamp_() != 0) {
    _internal_set_timestamp_(from._internal_timestamp_());
  }
  if (from._internal_frame_type_() != 0) {
    _internal_set_frame_type_(from._internal_frame_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Frame, frame_type__)
      + sizeof(Frame::frame_type__)
      - PROTOBUF_FIELD_OFFSET(Frame, sequence_id__)>(
          reinterpret_cast<char*>(&sequence_id__),
          reinterpret_cast<char*>(&other->sequence_id__));
}

std::string Frame::GetTypeName() const {
  return "x3.Frame";
}


// ===================================================================

class Check::_Internal {
 public:
};

Check::Check(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  md5sum_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Check)
}
Check::Check(const Check& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      md5sum_(from.md5sum_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:x3.Check)
}

inline void Check::SharedCtor() {
}

Check::~Check() {
  // @@protoc_insertion_point(destructor:x3.Check)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Check::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Check::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Check::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Check)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  md5sum_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Check::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes md5sum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_md5sum();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Check::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Check)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes md5sum = 1;
  for (int i = 0, n = this->_internal_md5sum_size(); i < n; i++) {
    const auto& s = this->_internal_md5sum(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Check)
  return target;
}

size_t Check::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Check)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes md5sum = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(md5sum_.size());
  for (int i = 0, n = md5sum_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      md5sum_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Check::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Check*>(
      &from));
}

void Check::MergeFrom(const Check& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Check)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  md5sum_.MergeFrom(from.md5sum_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Check::CopyFrom(const Check& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Check)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Check::IsInitialized() const {
  return true;
}

void Check::InternalSwap(Check* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  md5sum_.InternalSwap(&other->md5sum_);
}

std::string Check::GetTypeName() const {
  return "x3.Check";
}


// ===================================================================

class Addition::_Internal {
 public:
  static const ::x3::Check& check_(const Addition* msg);
  static const ::x3::Frame& frame_(const Addition* msg);
};

const ::x3::Check&
Addition::_Internal::check_(const Addition* msg) {
  return *msg->check__;
}
const ::x3::Frame&
Addition::_Internal::frame_(const Addition* msg) {
  return *msg->frame__;
}
Addition::Addition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.Addition)
}
Addition::Addition(const Addition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_check_()) {
    check__ = new ::x3::Check(*from.check__);
  } else {
    check__ = nullptr;
  }
  if (from._internal_has_frame_()) {
    frame__ = new ::x3::Frame(*from.frame__);
  } else {
    frame__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:x3.Addition)
}

inline void Addition::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&check__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame__) -
    reinterpret_cast<char*>(&check__)) + sizeof(frame__));
}

Addition::~Addition() {
  // @@protoc_insertion_point(destructor:x3.Addition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Addition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete check__;
  if (this != internal_default_instance()) delete frame__;
}

void Addition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Addition::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.Addition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && check__ != nullptr) {
    delete check__;
  }
  check__ = nullptr;
  if (GetArenaForAllocation() == nullptr && frame__ != nullptr) {
    delete frame__;
  }
  frame__ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* Addition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .x3.Check check_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .x3.Frame frame_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Addition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.Addition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .x3.Check check_ = 1;
  if (this->_internal_has_check_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::check_(this),
        _Internal::check_(this).GetCachedSize(), target, stream);
  }

  // .x3.Frame frame_ = 2;
  if (this->_internal_has_frame_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::frame_(this),
        _Internal::frame_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.Addition)
  return target;
}

size_t Addition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.Addition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .x3.Check check_ = 1;
  if (this->_internal_has_check_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *check__);
  }

  // .x3.Frame frame_ = 2;
  if (this->_internal_has_frame_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *frame__);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Addition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Addition*>(
      &from));
}

void Addition::MergeFrom(const Addition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.Addition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_check_()) {
    _internal_mutable_check_()->::x3::Check::MergeFrom(from._internal_check_());
  }
  if (from._internal_has_frame_()) {
    _internal_mutable_frame_()->::x3::Frame::MergeFrom(from._internal_frame_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Addition::CopyFrom(const Addition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.Addition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Addition::IsInitialized() const {
  return true;
}

void Addition::InternalSwap(Addition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Addition, frame__)
      + sizeof(Addition::frame__)
      - PROTOBUF_FIELD_OFFSET(Addition, check__)>(
          reinterpret_cast<char*>(&check__),
          reinterpret_cast<char*>(&other->check__));
}

std::string Addition::GetTypeName() const {
  return "x3.Addition";
}


// ===================================================================

class MessagePack::_Internal {
 public:
  static const ::x3::Addition& addition_(const MessagePack* msg);
};

const ::x3::Addition&
MessagePack::_Internal::addition_(const MessagePack* msg) {
  return *msg->addition__;
}
MessagePack::MessagePack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:x3.MessagePack)
}
MessagePack::MessagePack(const MessagePack& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  content__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    content__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content_().empty()) {
    content__.Set(from._internal_content_(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_addition_()) {
    addition__ = new ::x3::Addition(*from.addition__);
  } else {
    addition__ = nullptr;
  }
  ::memcpy(&flow__, &from.flow__,
    static_cast<size_t>(reinterpret_cast<char*>(&type__) -
    reinterpret_cast<char*>(&flow__)) + sizeof(type__));
  // @@protoc_insertion_point(copy_constructor:x3.MessagePack)
}

inline void MessagePack::SharedCtor() {
content__.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  content__.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&addition__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type__) -
    reinterpret_cast<char*>(&addition__)) + sizeof(type__));
}

MessagePack::~MessagePack() {
  // @@protoc_insertion_point(destructor:x3.MessagePack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessagePack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  content__.Destroy();
  if (this != internal_default_instance()) delete addition__;
}

void MessagePack::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MessagePack::Clear() {
// @@protoc_insertion_point(message_clear_start:x3.MessagePack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  content__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && addition__ != nullptr) {
    delete addition__;
  }
  addition__ = nullptr;
  ::memset(&flow__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type__) -
      reinterpret_cast<char*>(&flow__)) + sizeof(type__));
  _internal_metadata_.Clear<std::string>();
}

const char* MessagePack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .x3.MessagePack.Flow flow_ = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_flow_(static_cast<::x3::MessagePack_Flow>(val));
        } else
          goto handle_unusual;
        continue;
      // .x3.MessagePack.Type type_ = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type_(static_cast<::x3::MessagePack_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // .x3.Addition addition_ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_addition_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes content_ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_content_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessagePack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:x3.MessagePack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .x3.MessagePack.Flow flow_ = 1;
  if (this->_internal_flow_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_flow_(), target);
  }

  // .x3.MessagePack.Type type_ = 2;
  if (this->_internal_type_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type_(), target);
  }

  // .x3.Addition addition_ = 3;
  if (this->_internal_has_addition_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::addition_(this),
        _Internal::addition_(this).GetCachedSize(), target, stream);
  }

  // bytes content_ = 4;
  if (!this->_internal_content_().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_content_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:x3.MessagePack)
  return target;
}

size_t MessagePack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:x3.MessagePack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes content_ = 4;
  if (!this->_internal_content_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_content_());
  }

  // .x3.Addition addition_ = 3;
  if (this->_internal_has_addition_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *addition__);
  }

  // .x3.MessagePack.Flow flow_ = 1;
  if (this->_internal_flow_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_flow_());
  }

  // .x3.MessagePack.Type type_ = 2;
  if (this->_internal_type_() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type_());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessagePack::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MessagePack*>(
      &from));
}

void MessagePack::MergeFrom(const MessagePack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:x3.MessagePack)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_content_().empty()) {
    _internal_set_content_(from._internal_content_());
  }
  if (from._internal_has_addition_()) {
    _internal_mutable_addition_()->::x3::Addition::MergeFrom(from._internal_addition_());
  }
  if (from._internal_flow_() != 0) {
    _internal_set_flow_(from._internal_flow_());
  }
  if (from._internal_type_() != 0) {
    _internal_set_type_(from._internal_type_());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessagePack::CopyFrom(const MessagePack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:x3.MessagePack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessagePack::IsInitialized() const {
  return true;
}

void MessagePack::InternalSwap(MessagePack* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &content__, lhs_arena,
      &other->content__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessagePack, type__)
      + sizeof(MessagePack::type__)
      - PROTOBUF_FIELD_OFFSET(MessagePack, addition__)>(
          reinterpret_cast<char*>(&addition__),
          reinterpret_cast<char*>(&other->addition__));
}

std::string MessagePack::GetTypeName() const {
  return "x3.MessagePack";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace x3
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::x3::CharArray*
Arena::CreateMaybeMessage< ::x3::CharArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::CharArray >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::FloatArray*
Arena::CreateMaybeMessage< ::x3::FloatArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::FloatArray >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::FloatMatrix*
Arena::CreateMaybeMessage< ::x3::FloatMatrix >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::FloatMatrix >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Point*
Arena::CreateMaybeMessage< ::x3::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Points*
Arena::CreateMaybeMessage< ::x3::Points >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Points >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Box*
Arena::CreateMaybeMessage< ::x3::Box >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Box >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Attributes*
Arena::CreateMaybeMessage< ::x3::Attributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Attributes >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::DBResult*
Arena::CreateMaybeMessage< ::x3::DBResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::DBResult >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Image*
Arena::CreateMaybeMessage< ::x3::Image >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Image >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Enable*
Arena::CreateMaybeMessage< ::x3::Enable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Enable >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Threshold*
Arena::CreateMaybeMessage< ::x3::Threshold >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Threshold >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Mode*
Arena::CreateMaybeMessage< ::x3::Mode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Mode >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Target*
Arena::CreateMaybeMessage< ::x3::Target >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Target >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::SmartFrameMessage*
Arena::CreateMaybeMessage< ::x3::SmartFrameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::SmartFrameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Capture*
Arena::CreateMaybeMessage< ::x3::Capture >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Capture >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::CaptureTarget*
Arena::CreateMaybeMessage< ::x3::CaptureTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::CaptureTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::CaptureFrameMessage*
Arena::CreateMaybeMessage< ::x3::CaptureFrameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::CaptureFrameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::StatisticsMessage*
Arena::CreateMaybeMessage< ::x3::StatisticsMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::StatisticsMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::FrameMessage*
Arena::CreateMaybeMessage< ::x3::FrameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::FrameMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Capability*
Arena::CreateMaybeMessage< ::x3::Capability >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Capability >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Version*
Arena::CreateMaybeMessage< ::x3::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Config*
Arena::CreateMaybeMessage< ::x3::Config >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Config >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Status*
Arena::CreateMaybeMessage< ::x3::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Command*
Arena::CreateMaybeMessage< ::x3::Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Command >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Response*
Arena::CreateMaybeMessage< ::x3::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::LogLevel*
Arena::CreateMaybeMessage< ::x3::LogLevel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::LogLevel >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::InfoMessage*
Arena::CreateMaybeMessage< ::x3::InfoMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::InfoMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Frame*
Arena::CreateMaybeMessage< ::x3::Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Check*
Arena::CreateMaybeMessage< ::x3::Check >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Check >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::Addition*
Arena::CreateMaybeMessage< ::x3::Addition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::Addition >(arena);
}
template<> PROTOBUF_NOINLINE ::x3::MessagePack*
Arena::CreateMaybeMessage< ::x3::MessagePack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::x3::MessagePack >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
